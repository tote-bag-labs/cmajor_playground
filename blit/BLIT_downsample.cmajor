
/*
    This file was auto-generated by the cmaj VScode extension!
    https://cmajor.dev
*/


graph BlitDownsampler() [[ main ]]
{
   input stream float<2> in;
   output stream float<2> out;

    // this is not incrementing at the rate I want-why?
   input event float sampleRate [[name: "Sample Rate", min: 100.0f, max: 44100.0f, init: 44100.0f,  step: 200.0f]];
   input outputGain.volume outGain [[name: "Output Gain", min: -120.0,   max: 24.0, init: 0.0, step: 0.01, unit: "dB" ]];
   input event float qualityIn     [[ name: "Out Filter Q",         min: 1.0,             max: 10.0,          init: 1.0,  step: 0.01]];
   input event float satIn         [[ name: "Out Filter Saturation",min: 1.0,             max: 10.0,          init: 1.5,  step: 0.01]];
   input event float nlIn          [[ name: "NonLinear", min: 0,               max: 1,             init: 1,     text: "Off|On"]];

   let oversampleRate = 4;

   event qualityIn(float q)
   {
    outputFilterLeft.qualityIn <- q;
    outputFilterRight.qualityIn <- q;
   }

   event satIn(float s)
   {
    outputFilterLeft.satIn <- s;
    outputFilterRight.satIn <- s;
   }

   event nlIn(float nl)
   {
    outputFilterLeft.nlIn <- nl;
    outputFilterRight.nlIn <- nl;
   }

   event sampleRate(float fs)
   {
    blit.frequency <- fs;
    
    // TODO: move these into the blit processor when refactored in order
    // to allow this.
    let nyquist = fs / 2.0f;

    outputFilterLeft.frequencyIn <- nyquist;
    outputFilterRight.frequencyIn <- nyquist;
   }

    node blit = downsampleBlit(float32<2>) * oversampleRate;
    node inputFilter = std::filters (float32<2>)::simper::Processor() * oversampleRate;
    node outputGain = std::levels::SmoothedGain (float32<2>);

    node toMono = SplitMono(float32);
    node toStereo = MergeStereo(float32);

    // This have to be declared this way because the processor doesn't support multiple channels
    // TODO: move these to inside the BLIT processor when the pirkle stuff has been refactored
    // to allow this.
    node outputFilterLeft = pirkle_va::moog_ladder::Processor * oversampleRate;
    node outputFilterRight = pirkle_va::moog_ladder::Processor * oversampleRate;

 
   connection
   {
        in -> blit.in;
        blit.out -> toMono.in;
        toMono.outLeft -> outputFilterLeft.in;
        toMono.outRight -> outputFilterRight.in;
        outputFilterLeft.out -> toStereo.inLeft;
        outputFilterRight.out -> toStereo.inRight;
        toStereo.out -> outputGain.in;
        outputGain.out -> out;
   }
}

processor downsampleBlit (using FrameType = float32)
{
    input stream FrameType in;
    output stream FrameType out;

    input event float frequency [[ name: "Frequency", min: 100.0f, max: 44100.0f, init: 44100.0f]];

    event frequency(float f)
    {
        smoothedFrequency.setTarget(f, smoothingFrames);
    }

    node blit = blitOscillator(float32);
    var inputFilter = std::filters(float32<2>)::simper::create (0, processor.frequency, 44100.0f, 1.0f, 1.0f);

    let smoothingSeconds = 10.0f * .001f;
    int smoothingFrames = 0;
    std::smoothing(float32)::SmoothedValue smoothedFrequency;

    void main()
    {
        smoothingFrames = int32(processor.frequency * smoothingSeconds);

        loop
        {
            let currentFrequency = smoothedFrequency.currentValue();
            let nextFrequency = smoothedFrequency.getNext();
            if (nextFrequency != currentFrequency)
            {
                blit.frequency <- nextFrequency;

                // we want to filter at new nyquist - ish before downsample to prevent some aliasing
                //https://github.com/mwcm/pitcher/blob/master/pitcher/core.py
                let nyquist = nextFrequency / 2.0f;
                inputFilter.setFrequency(processor.frequency, nyquist * .66f, 2.0f, 1.0f);
            }

           out <- inputFilter.process(in) * blit.out;

           blit.advance();
           advance();
        }
    }
}

processor blitOscillator  (using FrameType = float32,
                            using CoefficientType = float32)
{
    input stream FrameType in;
    output stream FrameType out;
    input event CoefficientType frequency [[ name: "Frequency", min: 5.0f, max: 44100.0f, init: initFrequency]];

    event frequency (CoefficientType f)
    {
        setup(f);
    }

    let initFrequency = 44100.0f;

    void setup(CoefficientType f)
    {
        let P = CoefficientType(processor.frequency) / f;
        M = 2 * int32(floor(P / 2)) + 1;
        M_P = CoefficientType(M)/P;
        rate = CoefficientType(pi) / P;

        initialised = true;
    }

    float tick(float x)
    {
        let M_P_phase = M_P * phase;

        let denominator = M * sin((M_P_phase) / M);

        if (denominator <= 1e-7)
        {
            return M_P;
        }

        return M_P * (sin(M_P_phase) / denominator);
    }

    bool initialised = false;
    int M = 0;
    CoefficientType M_P = 0.0;
    CoefficientType phase = 0.0;
    CoefficientType rate = 0.0;

    void main()
    {
        if(!initialised)
        {
            setup(initFrequency);
        }

        loop
        {
            out <- tick(phase);

            phase += rate;
            if (phase >= pi)
            {
                phase -= CoefficientType(pi);
            }

           advance();
        }
    }
}


